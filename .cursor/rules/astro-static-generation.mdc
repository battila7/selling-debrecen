---
description: "Astro Static Generation"
---
# Astro Static Site Generation

Best practices for static site generation (SSG) patterns and build-time optimization in Astro.

<rule>
name: astro_static_generation
description: Standards for implementing static site generation in Astro
filters:
  - type: file_extension
    pattern: "\\.astro$"
  - type: content
    pattern: "getStaticPaths|export const prerender"

actions:
  - type: suggest
    message: |
      Follow these static site generation best practices for Astro:

      ## Core SSG Principles

      1. **Everything is Static by Default** - All pages are pre-rendered at build time
      2. **Build Once, Serve Everywhere** - Generate HTML at build time, not request time
      3. **No Server Required** - Output can be hosted on any static host (Netlify, Vercel, GitHub Pages)

      ## getStaticPaths Patterns

      ### Basic Static Path Generation
      ```astro
      ---
      // src/pages/users/[id].astro
      import type { GetStaticPaths } from 'astro';
      
      // ✅ GOOD: Generate paths at build time
      export const getStaticPaths = (async () => {
        const users = [
          { id: '1', name: 'Alice' },
          { id: '2', name: 'Bob' },
          { id: '3', name: 'Charlie' }
        ];
        
        return users.map(user => ({
          params: { id: user.id },
          props: { user }
        }));
      }) satisfies GetStaticPaths;
      
      interface Props {
        user: { id: string; name: string };
      }
      
      const { user } = Astro.props;
      ---
      
      <h1>{user.name}</h1>
      ```

      ### Fetching Data at Build Time
      ```astro
      ---
      import type { GetStaticPaths } from 'astro';
      
      // ✅ GOOD: API calls happen once at build time
      export const getStaticPaths = (async () => {
        const response = await fetch('https://api.example.com/products');
        const products = await response.json();
        
        return products.map((product: any) => ({
          params: { id: product.id.toString() },
          props: { product }
        }));
      }) satisfies GetStaticPaths;
      
      const { product } = Astro.props;
      ---
      
      <article>
        <h1>{product.name}</h1>
        <p>{product.description}</p>
        <p>${product.price}</p>
      </article>
      ```

      ### Multiple API Sources
      ```astro
      ---
      import type { GetStaticPaths } from 'astro';
      
      export const getStaticPaths = (async () => {
        // ✅ GOOD: Parallel fetching at build time
        const [products, categories, reviews] = await Promise.all([
          fetch('https://api.example.com/products').then(r => r.json()),
          fetch('https://api.example.com/categories').then(r => r.json()),
          fetch('https://api.example.com/reviews').then(r => r.json())
        ]);
        
        return products.map((product: any) => {
          const productReviews = reviews.filter(
            (r: any) => r.productId === product.id
          );
          const category = categories.find(
            (c: any) => c.id === product.categoryId
          );
          
          return {
            params: { id: product.id.toString() },
            props: { product, category, reviews: productReviews }
          };
        });
      }) satisfies GetStaticPaths;
      ---
      ```

      ### Content Collections with Static Paths
      ```astro
      ---
      import { getCollection } from 'astro:content';
      import type { GetStaticPaths } from 'astro';
      import type { CollectionEntry } from 'astro:content';
      
      export const getStaticPaths = (async () => {
        // Filter drafts in production
        const posts = await getCollection('blog', ({ data }) => {
          return import.meta.env.PROD ? !data.draft : true;
        });
        
        return posts.map(post => ({
          params: { slug: post.slug },
          props: { post }
        }));
      }) satisfies GetStaticPaths;
      
      interface Props {
        post: CollectionEntry<'blog'>;
      }
      
      const { post } = Astro.props;
      const { Content, headings } = await post.render();
      ---
      
      <article>
        <h1>{post.data.title}</h1>
        <Content />
      </article>
      ```

      ## Build-Time Data Fetching

      ### Cached API Requests
      ```astro
      ---
      // utils/buildCache.ts
      const buildCache = new Map<string, any>();
      
      export async function cachedFetch(url: string) {
        if (buildCache.has(url)) {
          return buildCache.get(url);
        }
        
        const response = await fetch(url);
        const data = await response.json();
        buildCache.set(url, data);
        
        return data;
      }
      ---
      ```

      ```astro
      ---
      // src/pages/products/[id].astro
      import { cachedFetch } from '../../utils/buildCache';
      
      export const getStaticPaths = async () => {
        // ✅ GOOD: Shared data cached across builds
        const products = await cachedFetch('https://api.example.com/products');
        const categories = await cachedFetch('https://api.example.com/categories');
        
        return products.map((product: any) => ({
          params: { id: product.id },
          props: { 
            product,
            category: categories.find((c: any) => c.id === product.categoryId)
          }
        }));
      };
      ---
      ```

      ### Local Data Files
      ```astro
      ---
      import type { GetStaticPaths } from 'astro';
      import data from '../../data/products.json';
      
      // ✅ GOOD: Use local data files for static content
      export const getStaticPaths = (() => {
        return data.products.map(product => ({
          params: { id: product.id },
          props: { product }
        }));
      }) satisfies GetStaticPaths;
      ---
      ```

      ## Environment-Specific Builds

      ### Build-Time Environment Variables
      ```astro
      ---
      // ✅ GOOD: Use import.meta.env for build-time variables
      const apiUrl = import.meta.env.PUBLIC_API_URL;
      const apiKey = import.meta.env.API_KEY; // Private, only available server-side
      
      export async function getStaticPaths() {
        // API calls use environment variables at build time
        const response = await fetch(`${apiUrl}/data`, {
          headers: { 'Authorization': `Bearer ${apiKey}` }
        });
        const data = await response.json();
        
        return data.map((item: any) => ({
          params: { id: item.id },
          props: { item }
        }));
      }
      ---
      ```

      ### Production vs Development Builds
      ```astro
      ---
      import { getCollection } from 'astro:content';
      
      export async function getStaticPaths() {
        const posts = await getCollection('blog', ({ data }) => {
          // ✅ GOOD: Show drafts in dev, hide in production
          if (import.meta.env.DEV) {
            return true;
          }
          return !data.draft && !data.future;
        });
        
        // ✅ GOOD: Different data sources by environment
        const apiUrl = import.meta.env.PROD
          ? 'https://api.example.com'
          : 'http://localhost:3001';
        
        return posts.map(post => ({
          params: { slug: post.slug },
          props: { post }
        }));
      }
      ---
      ```

      ## Optimizing Build Performance

      ### Limit Path Generation in Development
      ```astro
      ---
      import type { GetStaticPaths } from 'astro';
      
      export const getStaticPaths = (async () => {
        const allPosts = await getCollection('blog');
        
        // ✅ GOOD: Generate fewer paths in dev for faster builds
        const posts = import.meta.env.DEV 
          ? allPosts.slice(0, 10) 
          : allPosts;
        
        return posts.map(post => ({
          params: { slug: post.slug },
          props: { post }
        }));
      }) satisfies GetStaticPaths;
      ---
      ```

      ### Parallel Path Generation
      ```astro
      ---
      export const getStaticPaths = async () => {
        // ✅ GOOD: Fetch data sources in parallel
        const [posts, products, authors] = await Promise.all([
          getCollection('blog'),
          fetch('https://api.example.com/products').then(r => r.json()),
          getCollection('authors')
        ]);
        
        return posts.map(post => {
          const author = authors.find(a => a.id === post.data.authorId);
          return {
            params: { slug: post.slug },
            props: { post, author }
          };
        });
      };
      ---
      ```

      ## Static Assets and Images

      ### Optimized Image Loading
      ```astro
      ---
      import { Image } from 'astro:assets';
      import type { GetStaticPaths } from 'astro';
      
      export const getStaticPaths = (async () => {
        const products = await fetch('https://api.example.com/products')
          .then(r => r.json());
        
        return products.map((product: any) => ({
          params: { id: product.id },
          props: { 
            product,
            // ✅ GOOD: Image URLs prepared at build time
            imageUrl: product.imageUrl
          }
        }));
      }) satisfies GetStaticPaths;
      
      const { product, imageUrl } = Astro.props;
      ---
      
      <!-- Images optimized at build time -->
      <Image 
        src={imageUrl}
        alt={product.name}
        width={800}
        height={600}
        format="webp"
      />
      ```

      ### Local Image Assets
      ```astro
      ---
      import { Image } from 'astro:assets';
      import heroImage from '../assets/hero.jpg';
      
      // ✅ GOOD: Local images optimized at build time
      ---
      
      <Image 
        src={heroImage}
        alt="Hero"
        widths={[400, 800, 1200]}
        sizes="(max-width: 768px) 100vw, 800px"
      />
      ```

      ## Handling Large Sites

      ### Pagination for Large Collections
      ```astro
      ---
      // src/pages/blog/[...page].astro
      import type { GetStaticPaths } from 'astro';
      
      export const getStaticPaths = (async ({ paginate }) => {
        const posts = await getCollection('blog');
        
        // ✅ GOOD: Paginate large collections
        return paginate(posts, {
          pageSize: 20,
          props: { 
            // Additional props available to all pages
            totalPosts: posts.length 
          }
        });
      }) satisfies GetStaticPaths;
      
      const { page } = Astro.props;
      ---
      
      {page.data.map(post => (
        <article>{post.data.title}</article>
      ))}
      ```

      ### Incremental Static Generation (Prerender Flag)
      ```astro
      ---
      // src/pages/dynamic-data.astro
      
      // ✅ GOOD: Opt out of prerendering for specific pages
      export const prerender = false;
      
      // This page will be server-rendered if using hybrid mode
      const liveData = await fetch('https://api.example.com/live');
      ---
      ```

      ## Build Output Optimization

      ### Output Configuration
      ```javascript
      // astro.config.mjs
      import { defineConfig } from 'astro/config';
      
      export default defineConfig({
        // ✅ GOOD: Static output for SSG
        output: 'static',
        
        build: {
          // Optimize asset handling
          assets: '_assets',
          // Inline small assets
          inlineStylesheets: 'auto',
        }
      });
      ```

      ### Hybrid Mode (Selective SSR)
      ```javascript
      // astro.config.mjs
      export default defineConfig({
        // Mix static and server-rendered pages
        output: 'hybrid',
        adapter: netlify()
      });
      ```

      ```astro
      ---
      // Most pages are static by default in hybrid mode
      // src/pages/about.astro - automatically static
      ---
      
      <h1>About</h1>
      ```

      ```astro
      ---
      // src/pages/api/data.astro - opt into SSR
      export const prerender = false;
      
      // This endpoint is server-rendered on demand
      ---
      ```

      ## RSS Feed Generation
      ```astro
      ---
      // src/pages/rss.xml.ts
      import rss from '@astrojs/rss';
      import { getCollection } from 'astro:content';
      
      export async function GET(context) {
        const posts = await getCollection('blog');
        
        return rss({
          title: 'My Blog',
          description: 'A humble blog',
          site: context.site,
          items: posts.map(post => ({
            title: post.data.title,
            pubDate: post.data.publishedDate,
            description: post.data.description,
            link: `/blog/${post.slug}/`,
          })),
        });
      }
      ```

      ## Static Data Endpoints

      ### JSON API Endpoints
      ```typescript
      // src/pages/api/posts.json.ts
      import { getCollection } from 'astro:content';
      
      export async function GET() {
        const posts = await getCollection('blog', ({ data }) => !data.draft);
        
        // ✅ GOOD: Generate JSON at build time
        return new Response(
          JSON.stringify(posts.map(post => ({
            slug: post.slug,
            title: post.data.title,
            description: post.data.description
          }))),
          {
            status: 200,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
      }
      ```

      ## Common Pitfalls

      ### Don't Fetch Per Page Render
      ```astro
      <!-- ❌ BAD: Fetching in component (doesn't work in SSG) -->
      ---
      // src/components/UserProfile.astro
      const { userId } = Astro.props;
      const user = await fetch(`https://api.example.com/users/${userId}`);
      ---
      
      <!-- ✅ GOOD: Fetch in getStaticPaths -->
      ---
      // src/pages/users/[id].astro
      export async function getStaticPaths() {
        const users = await fetch('https://api.example.com/users')
          .then(r => r.json());
        return users.map(user => ({
          params: { id: user.id },
          props: { user }
        }));
      }
      const { user } = Astro.props;
      ---
      ```

      ### Handle API Failures at Build Time
      ```astro
      ---
      export const getStaticPaths = async () => {
        try {
          const response = await fetch('https://api.example.com/data');
          
          // ✅ GOOD: Handle errors gracefully
          if (!response.ok) {
            console.error('API error:', response.status);
            return [];
          }
          
          const data = await response.json();
          return data.map(item => ({
            params: { id: item.id },
            props: { item }
          }));
        } catch (error) {
          console.error('Build-time fetch failed:', error);
          return [];
        }
      };
      ---
      ```

      ### Type Safety with Props
      ```astro
      ---
      import type { GetStaticPaths } from 'astro';
      
      // ✅ GOOD: Define prop types
      interface Props {
        product: {
          id: string;
          name: string;
          price: number;
        };
      }
      
      export const getStaticPaths = (async () => {
        const products = await fetch('https://api.example.com/products')
          .then(r => r.json());
        return products.map((product: any) => ({
          params: { id: product.id },
          props: { product }
        }));
      }) satisfies GetStaticPaths;
      
      const { product } = Astro.props;
      ---
      ```

      ## Build Verification

      ### Preview Build Output
      ```bash
      # Build the site
      npm run build
      
      # Preview the static output
      npm run preview
      ```

      ### Check Generated Files
      ```bash
      # Verify static files were generated
      ls -R dist/
      
      # Should see:
      # dist/
      # ├── index.html
      # ├── about/index.html
      # ├── blog/
      # │   ├── post-1/index.html
      # │   └── post-2/index.html
      # └── _astro/
      #     └── [hashed assets]
      ```

      ## Best Practices Checklist

      - [ ] All dynamic routes have `getStaticPaths` defined
      - [ ] API calls happen in `getStaticPaths`, not component body
      - [ ] Build-time data is cached when used across multiple pages
      - [ ] Images are optimized using Astro's Image component
      - [ ] Draft content filtered in production builds
      - [ ] Error handling for API failures at build time
      - [ ] Environment variables properly configured
      - [ ] Build output verified (dist/ directory)
      - [ ] Large collections paginated
      - [ ] Props are properly typed with TypeScript

examples:
  - input: |
      # Bad: No static paths
      const { id } = Astro.params;
      const data = await fetch(`/api/${id}`);
      
      # Good: Static paths with build-time data
      export const getStaticPaths = async () => {
        const items = await fetch('/api/all').then(r => r.json());
        return items.map(item => ({
          params: { id: item.id },
          props: { item }
        }));
      };
      const { item } = Astro.props;
    output: "Properly configured static site generation"
</rule>
